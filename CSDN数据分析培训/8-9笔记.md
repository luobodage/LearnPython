# 介绍

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif)

##### 1. NumPy

NumPy是Python的一种开源的数值计算扩展，可用来存储和处理大  型矩阵，比Python自身的列表结构要高效得多。NumPy底层使用 BLAS 作为向量，各种运算的速度也得到大幅提升。它主要包括：

◎ 强大的N维数组对象Array；

◎ 比较成熟的（广播）函数库；

◎ 用于整合C、C++和Fortran代码的工具包；

◎ 实用的线性代数、傅里叶变换和随机数生成函数，使 NumPy 和

稀疏矩阵运算包SciPy的配合使用更加方便。 另外，NumPy中的数据类型在 Pandas、Scikit-Learn、

StatsModels 等库中被作为基本数据类型使用。

##### 2. Pandas

Python 之所以能成为强力的数据分析工具，和 Pandas 库有很大的 关系。Pandas 的主要应用环境如下：

（1）数据的导入与导出；

（2）数据清理；

（3）数据挖掘与探索；

（4）为分析做数据处理与准备；

（5）结合Scikit-Learn、StatsModels进行分析。

用得最多的Pandas对象是DataFrame，它是一个两维数据 表结构，包含多行多列，如表1-1所示。

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image003.jpg) |





 

表1-1

相对于 R等统计软件，Pandas借鉴了 R的数据结构，因此拥有了 R 的很多方便的数据操作特性； 在语法设计上，Pandas比R和Stata更严谨  且更简洁易用；基于Python自动管理内存的能力，以及在很多细节上的 优化（比如在数据操作过程中的数据复制和引用），Pandas拥有了更好 的管理和计算大数据的能力。



Pandas的底层基于NumPy搭建，因此Pandas拥有了NumPy的全部优  点，比如Pandas定义的数据结构可以支持NumPy已经定义的计算，相当 于拥有了MATLAB的矩阵计算能力；NumPy原生的C接口也为扩展 Pandas的计算性能带来了很大的方便。 对于金融用户来讲，Pandas提供了一系列适用于金融数据的高性能 时间序列与工具，例如Panel、时间Series等。

##### 3. Matplotlib

Matplotlib是Python最著名的绘图库，提供了一整套和MATLAB相  似的命令API，十分适合进行交互式制图。我们也可以很方便地将它作 为绘图控件，嵌入GUI应用程序中Matplotlib 的文档相当完备， 而且在 Gallery 页面

[http：//matplotlib.org/gallery.html](http://xn--gzu811i/)

中有上百幅缩略图，打开后都有源 程序。因此，如果需要绘制某种类型的图，则只需在这个页面中浏览、 复制、粘贴，就基本可以搞定。

##### 4. Seaborn

Seaborn其实是在Matplotlib的基础上进行了更高级的API封装，从而 使作图更容易，如图 1-1 所示。在大多数情况下使用 Seaborn 就能制作出非常有吸引力的图，而使用Matplotlib就能制作出具有更多特色的图。笔者认为：应该把Seaborn视为Matplotlib的补充，而不是替代物。

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg) |







![文本框: z](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image005.gif)![文本框: 3 2 1 0](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image006.gif)![文本框: x](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image005.gif)![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image007.gif)

 

 

 

 

 

 

 

 

 

 

 

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image009.jpg)![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image011.jpg)![文本框: z](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image005.gif)![文本框: 3 2 1 0](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image012.gif)![文本框: 2](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image013.gif)rn ntom wit h fiII



![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image014.jpg)

 

 

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image016.jpg) |





 

Seaborn默认的浅灰色背景与白色网络线的灵感来源于Matplotlib， 却比Matplotlib的颜色更加柔和。我们发现，图对于传播信息很有用， 几乎在所有情况下，人们喜欢图更甚于表。

##### 5. SciPy

SciPy 包含致力于解决科学计算中常见问题的各个工具箱。它的不 同子模块相当于不同的应用，例如插值、积分、优化、图像处理、特殊 函数等。SciPy可以与其他标准科学计算程序库进行比较，比如GSL（GNU C或C++科学计算库）或者 MATLAB 工具箱。SciPy 是Python 中科学计 算程序的核心包， 用于有效地计算NumPy矩阵，让NumPy和SciPy协同 工作。



##### 6. Scikit-Learn

Scikit-Learn 是基于 Python 的机器学习模块，基于 BSD 开源许可 证。Scikit-Learn 的基本功能主要被分为6部分：分类、回归、聚类、数 据降维、模型选择和数据预处理，具体可以参考官方网站上的文档

http：//scikit-learn.org/stable/

对具体的机器学习问题的解决，通常可以分为三步： 数据准备与预 处理；

模型选择与训练；

模型验证与参数调优。

Scikit-Learn 封装了这 些步骤，使建模的过程更方便、简单和快捷#

# — Numpy

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif)

## 1.1  numpy 的使用

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image017.gif)

NumPy 是高性能科学计算和数据分析的基础包，是本章接下来要 讲解的 Pandas、Scikit-Learn、

StatModels等库的构建基础。对于一般的金融数据分析而言，其大 部分功能可由更高级的 Pandas 实现。我们并不需要在学习NumPy上花  费过多精力，但是回过头来面向numPy可以帮助我们更好地理解面

向数组编程的思维方式。 NumPy的引入约定为：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image018.gif) |





 

因此，一旦在代码中看到np，就是使用了NumPy。

## 1.2  多维数组 ndarray

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image019.gif)

NumPy 的主要对象是 ndarray，该对象是一个快速、灵活的大数据 容器。在此需要注意，在ndarray 与Python中内置的list、tuple并不相同： 在Python中，元素的数据类型可以不同；而在ndarray中，所有元素的数 据类型必须相同。

首先，我们利用NumPy中的array函数创建一个一维ndarray:

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image020.gif) |





 

等长序列组成的列表将会被转换为一个多维数组

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image021.gif) |





 

除了np.array函数，还有其他函数可以快速创建数组：



![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image022.gif)

## 1.3  数组索引，切片，赋值

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image019.gif)

索引切片的操作类似于Python的内置函数list，只不过是从一维拓展 到多维而已。首先，我们创建一个

3×3的ndarray：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image023.gif) |





## 1.4  基本的数组运算

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image024.gif)

ndarray 的一大特色就是可以将代码向量化。所谓向量化，就是对 一个复杂的对象进行整体操作， 而不是对其中的单个元素进行循环。NumPy 的大部分代码都是由 C 语言编写的，并且进行了高度优

化，这 大大加快了计算速度。

简单的数学运算可以直接在ndarray上运行，例如：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image025.gif) |





 

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image026.gif) |


在 NumPy 中还有一些内置的数学函数，可以帮助我们快速地对数据进行统计计算，比如sum、max、mean、std等。



 

基本的数组统计方法



| **方法**       | **说明**                          |
| -------------- | --------------------------------- |
| sum            | 对数组的全部或者轴向数据求和      |
| mean           | 算术平均数                        |
| std var        | 标准差，方差                      |
| min max        | 最大值和最小值                    |
| argmin argmax  | 最小元素和最大元素的索引          |
| cumsum cumprod | 所有元素累计求和 所有元素累计求积 |

 

## 1.5  随机数

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image027.gif)

NumPy还可以用来生成伪随机数，负责这一功能的是其子库 numpy.random。

首先，导入 numpy.random。为了更直观地展示随机数的生成过程，这里同时导入了Matplotlib，以将结果可视化：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image028.gif) |





 

例如，npr.rand函数可以用来生成[0，1）的随机多维数组：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image029.gif) |





 

稍微开动一下大脑，就可以将随机区间转化为[2，4）：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image030.gif) |





 

下表展示了生成简单随机数的函数及其参数和描述。

 

| **函数** | **参数**         | **描述**                               |
| -------- | ---------------- | -------------------------------------- |
| round    | d0,d1            | 生成半开区间[0,1)内的多维随机数        |
| randn    | d0,d1            | 生成来自正态分布的多个样本             |
| randint  | low,high,size    | 生成半开区间[low,high)内的随机样本整数 |
| chioce   | a,size,raplace,p | 生成在给定的一维数组中的随机样本       |

对表中的函数生成的随机数

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image031.gif) |







# 二 统计与分析模块Pandas

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image017.gif)

### 2.1  Pandas基础

#### 2.1.1 Pandas简介

**Pandas** 是Python的核心数据分析支持库，提供了快速、灵活、明确的数据结构，旨在简单、直观地处理关系型、标记型数据。Pandas 的目标是成为 Python 数据分析实践与实战的必备高级工具，其长远目标是成为**最强大、最灵活、可以支持任何语言的开源数据分析工具**。[pandas源代码](http://./pandas.html)

Pandas 适用于处理以下类型的数据：

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image032.gif)![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image032.gif)![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image032.gif)与 SQL 或 Excel 表类似的，含异构列的表格数据。有序和无序（即非固定频率）的时间序列数据。  带行列标签的矩阵数据，包括同构或异构型数据。

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image033.gif)任意其它形式的观测、统计数据集。 数据转入 Pandas 数据结构时不必事先标记。

Pandas 的主要数据结构是 Series(一维数据)与DataFrame(二维数据）。功能十分强大，下面仅列出了它的部分优势 ：

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image034.gif)![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image035.gif)![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image034.gif)处理浮点与非浮点数据里的缺失数据，表示为 NaN ； 大小可变：插入或删除 DataFrame 等多维对象的列；

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image036.gif)自动、显式数据对齐：显式地将对象与一组标签对齐，也可以忽略标签，在 Series、DataFrame

计算时自动与数据对齐；

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image036.gif)强大、灵活的分组（group by）功能：拆分-应用-组合数据集，聚合、转换数据；

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image036.gif)![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image036.gif)把 Python 和 NumPy 数据结构里不规则、不同索引的数据轻松地转换为 DataFrame 对象； 基于智能标签，对大型数据集进行切片、花式索引、子集分解等操作；

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image032.gif)直观地合并（merge）、连接（join）数据集；

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image032.gif)灵活地重塑（reshape）**、**透视（pivot）数据集；

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image032.gif)用于读取文本文件（CSV 等支持分隔符的文件）、Excel 文件、数据库等来源的数据，利用超快的

HDF5 格式保存 / 加载数据；

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image032.gif)时间序列：支持日期范围生成、频率转换、移动窗口统计、移动窗口线性回归、日期位移等时间序 列功能。

##### Pandas的数据结构

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image037.gif)Pandas 数据结构就像是低维数据的容器。比如，DataFrame 是 Series 的容器，而 Series 则是标量的容器。使用这种方式，可以在容器中以字典的形式插入或删除对象。

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image038.gif)Pandas 所有数据结构的值都是可变的，但数据结构的大小并非都是可变的，比如，Series 的长度不可改变，但 DataFrame 里就可以插入列。

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image034.gif)Pandas 里，绝大多数方法都不改变原始的输入数据，而是复制数据，生成新的对象。 一般来说， 原始输入数据不变更稳妥。

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image039.gif)处理 DataFrame 等表格数据时，**index**（行）或 **columns**（列）比 **axis 0** 和 **axis 1** 更直观。用这种方式迭代 DataFrame 的列，代码更易读易懂，

#### 2.1.2 Pandas的安装与导入

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image040.gif) |





 

**2.1.3** **Series** **一维数组**

Seriess是一维标记的数组，能够保存任何数据类型（整数，字符串，浮点数，Python对象等）。



| **values**  | **元素**             |
| ----------- | -------------------- |
| **index**   | 索引【行名称】       |
| **columns** | 列名称               |
| **dtypes**  | 数据类型             |
| **size**    | 元素个数             |
| **ndim**    | 维度                 |
| **shape**   | 数据形状（行列数目） |

 

##### ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image038.gif)创建Series对象

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image041.gif) |





 

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image042.gif)**Series****与****NumPy****的关系**

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image043.gif) |





 

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image039.gif)**Series****与****Python****数据类型的相互转换**

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image044.gif) |





 

**2.1.4** **DataFrame** **二维数组**

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image036.gif)**DataFrame****的创建**

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image045.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image046.gif)

 

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image039.gif)**创建不同数据类型的****DataFrame**

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image047.gif) |





 

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image032.gif)**DataFrame** **属性**

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image048.gif) |





 

**2.1.5** **数据提取**

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image049.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image050.gif)

 

**2.1.6** **Pandas****数据的增加、修改、删除**

 

| **loc**           | **查看数据，通过行名称**                                   |
| ----------------- | ---------------------------------------------------------- |
| **iloc**          | **查看数据，通过行下标**                                   |
| **ix**            | **混合索引既可以使用名称也可以使用下标的索引方式**，效率低 |
| **drop**          | **删除数据**                                               |
| labels[drop参数]  | 接收string或array。代表删除的行或列的标签。无默认。        |
| axis [drop参数]   | 接收0或1。代表操作的轴向。默认为0。                        |
| levels [drop参数] | 接收int或者索引名。代表标签所在级别。默认为None。          |
| inplace[drop参数] | 接收boolean。代表操作是否对原数据生效。默认为False。       |

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image051.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image052.gif)'height': [1.68, 1.37, 1.62]

}

df = pd.DataFrame(data)

 

\# 给数据data 增加一个 new_age列 【此列的值为age列的值+1】df.loc[:, 'new_age'] = df.loc[:, 'age'] + 1 print(data)

 

print('------------------------ 修改 ------------------------')

\# 更改所有年龄大于18的

\# 定位到age这一列数据，并进行判断 age >= 18的为True，否则为False res = data.loc[:, 'age'] >= 18

print(res)

 

 

 

\# 使用上面确定好的bool列，获取所有age >= 18的数据data_sex_man = data.loc[res, 'age'] print(data_sex_man)

 

 

\# 重写赋值【age >= 18的数据 改为 age = 17】df.loc[res,'age'] = 17

print(df)

 

 

 

print('------------------------ 删除 ------------------------')

\# inplace = True 对原df 产生影响，返回一个None

\# inplace = False 对原df 不产生影响，返回删除之后的结果

res = df.drop(labels = ['sex', 'age'], axis = 1, inplace = False)# 删除列

print(res)

 

res = df.drop(labels = [0, 1, 2, 3, 4, 5] , axis=0 , inplace = False)# 删除行

print(res)

 

\# # 删除age为偶数的行【小练习】

\# 确定age为偶数的行

bool_age = df.loc[:, 'age']%2 == 0

 

\# 获取age为偶数的行名称

age_name = df.loc[bool_age, :].index

 

\# 删除

res = df.drop(labels = age_name, axis = 0, inplace = False) print(res)

 

 

#### 2.1.7 Pandas数据加载



|              | **read_table****和****read_csv****常用参数及其说明**         |
| ------------ | ------------------------------------------------------------ |
| filepath     | 接收string。代表文件路径。无默认。                           |
| sep          | 接收string。代表分隔符。read_csv默认为“,”，read_table默认为制表符  “[Tab]”。 |
| header       | 接收int或sequence。表示将某行数据作为列名。默认为infer，表示自动识别。 |
| names        | 接收array。表示列名。默认为None。                            |
| index_col    | 接收int、sequence或False。表示索引列的位置，取值为sequence则代表多重 索引。默认为None. |
| dtype        | 接收dict。代表写入的数据类型（列名为key，数据格式为values）。默认为  None。 |
| engine       | 接收c或者python。代表数据解析引擎。默认为c。                 |
| nrows        | 接收int。表示读取前n行。默认为None。                         |
|              | **to_csv****常用参数及其说明**                               |
| path_or_buf  | 接收string。代表文件路径。无默认。                           |
| index        | 接收boolean，代表是否将行名（索引）写出。 默认为True。       |
| sep          | 接收string。代表分隔符。默认为“,”。                          |
| index_labels | 接收sequence。表示索引名。默认为None。                       |
| na_rep       | na_rep 接收string。代表缺失值。默认为“”。                    |
| columns      | columns 接收list。代表写出的列名。默认为None。               |
| encoding     | 接收特定string。代表存储文件的编码格式。默 认为None。        |
| mode         | 接收特定string。代表数据写入模式。默认为w。                  |
| header       | 接收boolean，代表是否将列名写出。默认为True。                |
|              | **read_excel****常用参数及其说明**                           |
| io           | 接收string。表示**文件路径**。无默认。                       |
| names        | 接收int、sequence或者False。表示索引列的位置，取值为sequence则代表多 重索引。默认为None。 |
| index_col    | 接收int、sequence或者False。表示索引列的位置，取值为sequence则代表多 重索引。默认为None。 |
| dtype        | 接收dict。代表写入的数据类型（列名为key，数据格式为values）。默认为  None。 |
| sheetname    | 接收string、int。代表excel表内数据的分表位置。默认为0。      |
| header       | 接收int或sequence。表示将某行数据作为列名。默认为infer，表示自动识别。 |

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image053.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image054.gif)

 

**2.1.8** **数据排序与合并**

##### ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image036.gif)数据排序



| **sort_index** |                                                          |
| -------------- | -------------------------------------------------------- |
| axis           | 0按照行名排序；1按照列名排序b                            |
| ascending      | 默认True升序排列；False降序排列                          |
| inplace        | 默认False，否则排序之后的数据直接替换原来的数据框        |
| inplace        | 默认False，否则排序之后的数据直接替换原来的数据框        |
| kind           | 默认quicksort，排序的方法                                |
| level          | 默认None，否则按照给定的level顺序排列---貌似并不是，文档 |
| na_position    | 缺失值默认排在最后                                       |
| by             | 按照那一列数据进行排序，但是by参数貌似不建议使用         |
| **sort_value** |                                                          |
| axis           | 0按照行名排序；1按照列名排序b                            |
| ascending      | 默认True升序排列；False降序排列                          |
| kind           | 默认quicksort，排序的方法                                |
| na_position    | 缺失值默认排在最后                                       |

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image055.gif) |





 

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image056.gif)rank排序

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image057.gif) |







 

 

| [-5, | 0,   | 2,   | 4,   | 4,   | 7,   | 8]   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| \|   | \|   | \|   | \|   | \|   | \|   | \|   |
| 1.0  | 2.0  | 3.0  | 4.5  | 4.5  | 6.0  | 7.0  |

 

 

 

 

 

 

 

 

 

 

 

##### ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image058.gif)![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image059.gif)数据的合并

 

| **concat**  |                                                              |
| ----------- | ------------------------------------------------------------ |
| objs:       | series，dataframe或者是panel构成的序列lsit                   |
| axis        | 需要合并链接的轴，0是行，1是列                               |
| join        | 连接的方式 inner，或者outer                                  |
| join_axes   | 根据那个指定轴来对齐数据【list类型】                         |
| **Merge**   |                                                              |
| left /right | 左表数据 / 右表数据                                          |
| how:        | 数据融合的方法                                               |
| on:         | 列名，用到这个参数的时候一定要保证坐表和右表用来对齐的那一列都有相同的列名。 |

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image060.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image061.gif)# outer 代表外连接,在行的方向上直接拼接，列的方向上求列的并集

res = pd.concat((data_1, data_2), axis = 0, join = 'outer') print(res)

\# inner 代表内连接,在行的方向上直接拼接，列的方向上求列的交集

res = pd.concat((data_1, data_2), axis = 0, join = 'inner') print(res)

 

\# 【列的方向拼接 axis = 1】

\# outer 代表外连接,在列的方向上直接拼接，行的方向上求列的并集

res = pd.concat((data_1, data_2), axis = 1, join = 'outer') print(res)

\# inner 代表内连接,在列的方向上直接拼接，行的方向上求列的交集

res = pd.concat((data_1, data_2), axis = 1, join = 'inner') print(res)

 

 

\# 主键拼接 【merge】 --- 没有行的方向上的拼接

\# 拼接方式

\# how = {'left', 'right', 'outer', 'inner'}

\# on 就是 值一样的列

 

\# left ---left outer 左外连接  key 列只关系 左表，右表不关心

res = pd.merge(left = data_1, right = data_2, how = 'left', on = 'key') print(res)

\# right right outer 右外连接，  key 列只关系 右表，左表不关心

res = pd.merge(left = data_1, right = data_2, how = 'right', on = 'key') print(res)

\# outer - 外连接  key值的列 求并集

res = pd.merge(left = data_1, right = data_2, how = 'outer', on = 'key') print(res)

\# inner - 内连接  key值的列 求交集

res = pd.merge(left = data_1, right = data_2, how = 'inner', on = 'key') print(res)

 

#### 2.1.9 数据统计



| **head** | **显示前五行，可传****int****参数****(****显示的条数****)** |
| -------- | ----------------------------------------------------------- |
| tail     | 显示后五行，可传int参数(显示的条数)                         |
| info     | 显示数据类型相关的内容                                      |
| describe | 显示数据汇总信息                                            |
| count    | 统计一共有多少条数据                                        |
| quantilr | 求数组的四分位数                                            |
| cumsum   | 累加求和                                                    |
| max      | 最小值                                                      |
| min      | 最大值                                                      |
| mean     | 均值                                                        |
| ptp      | 极差                                                        |
| median   | 中位数                                                      |
| std      | 标准差                                                      |
| var      | 方差                                                        |
| cov      | 协方差                                                      |

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image062.gif) |





 

**2.1.10** **数据分组与透视表**

##### ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image059.gif)分组聚合



| **by**         | **接收****list****，****string****，****mapping****或****generator****。用于确定进行分组的依据。无默** **认。** |
| -------------- | ------------------------------------------------------------ |
| **axis**       | 接收int。表示操作的轴向，默认对列进行操作。默认为0。         |
| **level**      | 接收int或者索引名。代表标签所在级别。默认为None。            |
| **as_index**   | 接收boolearn。表示聚合后的聚合标签是否以DataFrame索引形式输出。默认为  True。 |
| **sort**       | 接收boolearn。表示是否对分组依据分组标签进行排序。默认为True。 |
| **group_keys** | 接收boolearn。表示是否显示分组标签的名称。默认为True。       |
| **squeeze**    | 接收boolearn。表示是否在允许的情况下对返回数据进行降维。默认为False。 |

 

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image063.gif)import pandas as pd

 

 

import numpy as np

 

\# 加载数据

data = [

['python', 0, 'zs', 18, '男', '北京'],

['java', 1, 'ls', 18, '男', '山东'],

['php', 2, 'ws', 28, '女', '山西'],

['html', 3, 'qs', 19, '男', '北京'],

['c++n', 4, 'rs', 23, '男', '北京']

]

data = pd.DataFrame(data, columns = ['ORGANIZE_NAME', 'USER_ID', 'name', 'age', 'sex', 'p'])

 

\# 根据班级分组、统计学员的班级的平均年龄

\# groupby 分组

\# by ---指定分组的列，可以是单列 也可以是多列

res = data.groupby(by = 'ORGANIZE_NAME')['age'].mean() print(res)

\# 按照单列分组，获取多列的

res = data.groupby(by = 'ORGANIZE_NAME')[['age', 'USER_ID']].mean()

\# 按照多列分组，获取单列

res1 = data.groupby(by = ['ORGANIZE_NAME', 'p', 'sex'])['age'].mean() print(res,'\n',res1)

 

print('-*'*50)

\# 利用agg同时对age 求平均值、对userid 求最大值

res1 = data.agg({'age': np.mean, 'USER_ID': np.max}) print(res1)

 

\# 对age 和 USER_ID 同时分别求 和 和均值

res = data[['age', 'USER_ID']].agg([np.sum, np.mean]) print(res)

 

\# 对age USER_ID 求取不同个数的统计指标

res = data.agg({'age': np.min, 'USER_ID': [np.mean, np.sum]}) print(res)

 

 

\# 自定义函数进行计算 *



![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image064.gif)

 

##### ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image065.gif)![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image066.gif)透视表

 

| **index**    | **接收****string****或****list****。表示行索引键。** |
| ------------ | ---------------------------------------------------- |
| **columns**  | 接收string或list。表示列索引键。                     |
| **values**   | 接收array。表示聚合数据。默认为None。                |
| **aggfunc**  | 接收function。表示聚合函数。默认为None。             |
| **rownames** | 表示行分组键名。无默认                               |
| **colnames** | 表示列分组键名。无默认。                             |
| **dropna**   | 接收boolearn。表示是否删掉全为NaN的。默认为False。   |

 

| import pandas as pd  import numpy as np data = [ |          |         |      |      |       |
| ------------------------------------------------ | -------- | ------- | ---- | ---- | ----- |
| ['2018-07-01',                                   | '商品A', | '服饰', | 18,  | 2,   | 740], |
| ['2018-07-02',                                   | '商品s', | '食品', | 18,  | 2,   | 140], |
| ['2018-07-03',                                   | '商品A', | '服饰', | 18,  | 3,   | 840], |
| ['2018-07-04',                                   | '商品s', | '食品', | 18,  | 2,   | 640], |
| ['2018-07-05',                                   | '商品A', | '服饰', | 18,  | 5,   | 440], |
| ['2018-07-06',                                   | '商品s', | '食品', | 18,  | 6,   | 405], |
| ['2018-07-07',                                   | '商品A', | '服饰', | 18,  | 9,   | 4550] |

 

 

 

 

 

 

**2.1.11** **时间序列**



| **Timestamp**       | **最基础的时间类。表示某个时间点。在绝大多数的场景中的时间数据都是**  **Timestamp****形式的时间。** |
| ------------------- | ------------------------------------------------------------ |
| **Period**          | 表示单个时间跨度，或者某个时间段，                           |
| **Timedelta**       | 表示不同单位的时间                                           |
| **DatetimeIndex**   | 一组Timestamp构成的Index，可以用来作为Series或者DataFrame的索 引。 |
| **PeriodtimeIndex** | 一组Period构成的Index，可以用来作为Series或者DataFrame的索引。 |
| **TimedeltaIndex**  | 组Timedelta构成的Index，可以用来作为Series或者DataFrame的索引。 |

 

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image067.gif)# datetime64[ns] ---numpy 里面的时间点类型

\# Timestamp ---pandas 默认的时间点类型----封装了datetime64[ns]

\# DatetimeIndex  ---pandas 默认支持的时间序列结构

 

import pandas

\# 可以通过 pd.to_datetime 将时间点数据转化为pandas默认支持的时间点数据

res = pandas.to_datetime('2019-9-12') print(res, type(res))

 

\# 可以通过pd.to_datetime 或者pd.DatetimeIndex将时间序列转化为pandas默认支持的时间序列结构

res = pandas.to_datetime(['2019-9-11', '2019-9-12', '2019-9-13', '2019-9-14',

'2019-9-15'])

res1 = pandas.DatetimeIndex(['2019-9-11', '2019-9-12', '2019-9-13', '2019-9-14',

'2019-9-15'])

print(res, '\n', res1)

 

 

 

print('-*'*50)

\# 加载数据

data = pandas.DataFrame(res, columns = ['time']) print(data.loc[:, 'time'])

 

print('-*'*50)

 

\# 转化为pandas默认支持的时间序列结构

pandas_time = pandas.to_datetime(data.loc[:, 'time']) print(type(pandas_time))

 

 

\# 获取该时间序列的属性---可以通过列表推导式来获取时间点的属性

year = [i.year for i in pandas_time]

print("年：\n", year)

 

 

month = [i.month for i in pandas_time]

print("月：\n", month)

 

 

day = [i.day for i in pandas_time]

print("日：\n", day)

 

 

quarter = [i.quarter for i in pandas_time]

print("季度：\n", quarter)



![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image068.gif)

**2.2**  ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image069.gif)**Pandas****进阶****(1) ——** **绘图**

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image070.gif)

 

 

 

 

 

| [1,  | '北京', | 9240], |
| ---- | ------- | ------ |
| [2,  | '上海', | 8962], |
| [3,  | '深圳', | 8315], |
| [4,  | '广州', | 7409], |
| [5,  | '杭州', | 7330], |
| [6,  | '宁波', | 7000], |
| [7,  | '佛山', | 6889], |
| [8,  | '东莞', | 6809]] |



![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image071.gif)data = pd.DataFrame(data, columns = ['排名', '城市', '月均工资']) print(data)

 

\# 设置X坐标对应显示

data = data.set_index('城市') data.head()

 

\# 折线图

data[['月均工资']].plot()

 

\# 中文乱码问题

plt.rcParams['font.sans-serif'] = 'SimHei' #雅黑字体plt.rcParams['axes.unicode_minus'] = False plt.show()

 

 

 

 

\# 柱状图-kind 是指指定图的类型

data['月均工资'][:10].plot(kind = 'bar')

\# 也可以解决中文乱码

plt.rc('font', **{'family' : 'Microsoft YaHei, SimHei'}) plt.show()

 

 

\# 箱线图

data[['月均工资']].boxplot()

plt.rc('font', **{'family' : 'Microsoft YaHei, SimHei'}) plt.show()

 

\# 直方图

data[['月均工资']].hist()

plt.rc('font', **{'family' : 'Microsoft YaHei, SimHei'}) plt.show()

 

\# 绘制实例

import numpy as np

data = pd.DataFrame(np.random.rand(10, 4), columns= list('ABCD'))

 

\# bar 是指垂直方向绘图,

\# barh是指水平方向绘图

\# stacked=True 将数据堆叠起来data.plot(kind= 'bar') plt.show()

 

data.plot(kind= 'barh') plt.show()

 

data.plot(kind= 'barh', stacked= True) plt.show()

 

## 2.3  Pandas进阶(2) —— 数据质量分析

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image072.gif)

#### 2.3.1 缺失值处理

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image073.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image074.gif)

\# 删除，，填充，，，插值，这是我们处理缺失值常用的方法

 

\# 加载数据

data = [

[25698744, 5145, 444],

[ np.nan, np.nan, 445], [25698746, 5156,   np.nan],

[25698747, np.nan, 447],

[ np.nan, 5145, 448],

[25698749, np.nan, *],

[25698743, 5454, 450]

]

data = pd.DataFrame(data, columns = ['商品id', '类别id', '门店编号'])

 

 

 

\# 检测缺失值

print(data.isnull()) #True表示缺失值print(data.notnull()) #Flase表示缺失值

 

 

\# 统计缺失值

\# sum 统计的是true 所以建议使用isnull print(data.isnull().sum()) print(data.notnull().sum())

 

 

\# 缺失值的处理

\# 删除 ----会对数据产生很大的影响，造成数据缺失，所以在数据大部分为缺失值，才使用删除法

\#axis=【行0列1】

\# how=【删除方式，any=只要有缺失值，就删除[整行或者整列]，all=只有整列或者整行都是缺失值，才删除】

\# inplace=【是否影响原数据】

data.dropna(axis = 1, how = 'any', inplace = True) print(data)

 

 

 

 

\# 填充  --- 填充之后对结果影响不大的情况，可以使用

\# 为了对整体的数据不产生影响，，一般使用 --- 均值，中位数，众数【类别型数据】来进行填充

\# 众数

mode = data.loc[:, '商品ID'].mode()[0]

data.loc[:, '商品ID'].fillna(value = mode, inplace = True) mode = data.loc[:, '类别ID'].mode()[0]

data.loc[:, '类别ID'].fillna(value = mode, inplace = True) mode = data.loc[:, '门店编号'].mode()[0]

data.loc[:, '门店编号'].fillna(value = mode, inplace = True) print(data)

 

print('-*'*40)

\# 对于一些非空值的特殊符号的处理

\# 先将其转化为缺失值，在进行处理

data.replace(to_replace = '*', value = np.nan, inplace = True) mode = data.loc[:, '门店编号'].mode()[0]

data.loc[:, '门店编号'].fillna(value = mode, inplace = True)

print(data)



 

 

| #    | 插值           |      |                        |
| ---- | -------------- | ---- | ---------------------- |
| x    | = np.array([1, | 2,   | 3, 4, 5, 8, 9])        |
| y    | = np.array([3, | 5,   | 7, 9, 11, 17, 19])     |
| z    | = np.array([2, | 8,   | 18, 32, 50, 128, 162]) |

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

#### 2.3.2 ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image075.gif)异常值处理

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image076.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image077.gif)

\# # 以 detail 为例 展示以amounts 进行异常值剔除，查看detail结果

\# 加载数据

data = [

[25698744, 5145, 444],

[ np.nan, np.nan, 445], [25698746, 5156,   446],

[25698747, np.nan, 447],

[ np.nan, 5145, 448],

[25698749, np.nan, 9744000000],

 

| [25698743, | 5454, | 490], |
| ---------- | ----- | ----- |
| [25698743, | 5454, | 451], |
| [25698743, | 5454, | 454], |
| [25698743, | 5454, | 455], |
| [25698743, | 5454, | 456], |
| [25698743, | 5454, | 453], |
| [25698743, | 5454, | 453], |
| [25698743, | 5454, | 457], |
| [25698743, | 5454, | 457], |
| [25698743, | 5454, | 458]  |

]

 

data = pd.DataFrame(data, columns = ['商品id', '类别id', '门店编号']) print(data.shape)

 

 

 

\# 调用函数 进行detail中amount的异常值剔除

bool_num = three_sigma(data.loc[:, '门店编号'])

 

\# 获取正常的detail

detail = data.loc[bool_num, :] print(detail.shape)

 

 

 

 

 

\# 箱线图分析

 

\# qu %75的数

\# ql %25的数

\# 1.5 可以稍微调整，，一般使用1.5

\# iqr = qu - ql

\# 上限：qu + 1.5*iqr

\# 下限 ：ql - 1.5*iqr

 

 

def box_analysis(data): '''

进行箱线图分析，剔除异常值

:param data: series

:return: bool数组'''

 

qu = data.quantile(0.75) ql = data.quantile(0.25)

 

iqr = qu - ql



![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image078.gif)

 

#### 2.3.3 标准化数据

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image079.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image080.gif)'''

小数定标标准化

:param data: 传入的数据

:return: 标准化之后的数据

'''

data = data / (10**np.ceil(np.log10(data.abs().max()))) return data

 

 

\# 加载数据 验证标准化

data = [

[25698744, 5145, 444],

[ np.nan, np.nan, 445], [25698746, 5156,   446],

[25698747, np.nan, 447],

[ np.nan, 5145, 448],

[25698749, np.nan, 9744000000],

 

|            | [25698743, | 5454, | 490], |
| ---------- | ---------- | ----- | ----- |
| [25698743, | 5454,      | 451], |       |
| [25698743, | 5454,      | 454], |       |
| [25698743, | 5454,      | 455], |       |
| [25698743, | 5454,      | 456], |       |
| [25698743, | 5454,      | 453], |       |
| [25698743, | 5454,      | 453], |       |
| [25698743, | 5454,      | 457], |       |
| [25698743, | 5454,      | 457], |       |
| [25698743, | 5454,      | 458]  |       |
| ]          |            |       |       |

 

data = pd.DataFrame(data, columns = ['商品id', '类别id', '门店编号'])

 

\# 离查标准化

res = deviation(data.loc[:, '门店编号']) print(res)

print('*-'*40)

\# 标准差标准化

res = stand_sca(data.loc[:, '门店编号']) print(res)

print('*-'*40)

\# 小数定标标准化

res = desc_sca(data.loc[:, '门店编号']) print(res)

 

\# 方法总结：

\# 离差标准化方法简单,便于理解,标准化后的数据限定在[0, 1]区间内。

\# 标准差标准化受到数据分布的影响较小。

\# 小数定标标准化方法的适用范围广,并且受到数据分布的影响较小,相比较于前两种方法而言该方法适用程度适中。

# 三 数据可视化Matplotlib与Seaborn

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image081.gif)

 

作者：J.R. Johansson (邮箱：[jrjohansson@gmail.com](mailto:jrjohansson@gmail.com))

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image082.gif)最新版本的用法介绍见网站http://github.com/jrjohansson/scientific-python-lectures. 其他相关介绍见[h ttp://jrjohansson.github.io](http://jrjohansson.github.io/).



![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image083.gif)

# 简介

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image017.gif)

Matplotlib是一个绘制2D和3D科学图像的库，它包含了以下的优点：

\1.  容易学习和掌握

\2.  兼容LaTeX格式的标题和文档

\3.  可以控制图像中的每个元素，包括图像大小和扫描精度。

\4.  对于很多格式都可以高质量的输出图像，包括PNG，PDF，SVG，EPS和PGF.

\5.  可以生成图形用户界面（GUI），做到交互式的获取图像以及无脑生成图像文件（通常用于批量作 业）

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image084.gif)Matplotlib最重要的一个特点，也是它作出的图像非常适合作为科学出版物的原因，是因为图像可以完  全被程序所控制。这一点对于图像重现非常重要，同时为更新数据后重新作图以及改变图像形状提供了 方便。更多关于Matplotlib网页请见http://matplotlib.org/

在Python中调用Matplotlib函数包有两种方法，一种是在pylab模式中包含一个星号（简单的方法）

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image085.gif) |





 

另一种是在matplotlib.pyplot模式下使用plt（整洁的方法）：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image086.gif) |





 

# MATLAB样式的API

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image087.gif)

学习用matplotlib绘制图像最简单的方法使用matplotlib自身提供的类似MATLAB的API。它和MATLAB  绘制图像的函数非常相近，所以熟悉MATLAB的用户可以非常容易的上手。采用在pylab模式中包含星  号的方式可以使用matplotlib中的API：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image088.gif) |





## 例：

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image017.gif)

采用一个类似MATLAB作图的API，能够做出以下简单的图像：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image089.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image090.gif)

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image092.gif) |





MATLAB中大多数绘图相关的函数都能在pylab模式下实现。例如将多个图像绘制在一个窗口中，以及 选择颜色和线条类型：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image094.gif) |





 

pylab这种MATLAB格式的API有一个优点，对于MATLAB熟悉的用户能够非常容易上手，而且对于绘制 简单图像而言不需要花费很多精力去学习。

然而，对于并不是特别简单的图像，并不推荐使用MATLAB类似的API，学习使用matplotlib面向对象的 绘图API是一种更好更强大的方法。对于多个复杂图像绘制在一个窗口中，插入图像和加入其它成分这  样的复杂操作，matplotlib的API能够很好的解决。

# matplotlib面向对象的API

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image072.gif)



面向对象的程序的主要思路是让用户能够面向对象来使用函数和进行操作，而不是像MATLAB类似的

API一样采用全局的程序状态。Matplotlib的优势在绘制多个图像或者一个图像窗口中包含多个子图像的 时候能够彰显出来。

我们这次采用面向对象的API来绘制和前一个例子相似的图像，但是这次我们存储一个引用在新创建的

fig变量的图像中，而并不直接创建一个全局的图像，然后我们创建一个新的坐标轴图像axes（采用

Figure函数族中的add_axes方法）：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image096.gif) |





 

尽管代码看起来多了一点，但是我们现在能够完全掌控图像的坐标轴位置，并且能够在图像上轻易增加 多个坐标轴：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image097.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image099.gif)

如果我们并不关心坐标轴的位置是否要明确处于画图窗口的哪个位置，我们可以采用matplotlib布局工  具中的一个，例如subplots，用法如下：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image100.gif) |





 

 

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image101.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image103.gif)

 

这样的代码很简单，但是如果坐标轴或者标签重合在一起，就显得不太美观了。

我们可以采用fig.tight_layout方法来解决这个问题，它能够更自动调整坐标轴在图像窗口的位置，从而  避免重合的发生：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image105.gif) |





 

# 图像大小，纵横比和图像精度

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image106.gif)

Matplotlib在绘制Figure对象时，允许用户确定图像纵横比、图像精度和大小，采用figsize和dpi关键字  参数。figsize是关于图像宽度和高度（单位：英寸）的元组型变量，dpi是每英寸点数（像素）。为创  建一个800×400像素，每英寸点数为100的图像，代码如下：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image107.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image108.gif)

 

同样的操作可以在布局工具中运行，例如subplots函数：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image110.gif) |





 

# 保存图像

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image019.gif)

我们可以采用Figure函数族中的savefig方法来存储图像：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image111.gif) |





 

这里我们还可以确定图像精度，以及选择不同的输出格式：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image112.gif) |





## 可以存储什么样的格式？为获取最高质量图像，我们应该选择哪种格式？

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image072.gif)

Matplotlib可以产生各种高质量的输出格式，包括PNG，JPG，EPS，SVG，PGF和PDF。在学术论文中，如果可以的话推荐使用PDF格式（LaTeX文件编译pdflatex可以采用includegraphics来编译

PDF）。在一些情况下，PGF格式也是一种好的选择。

## 图例、标签和标题

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif)

既然我们已经介绍了绘图和添加坐标轴的基本方法，我们现在来介绍如何添加图例、标签和标题。

### 标题

标题可以加在每个图像上，可以采用set_title方法来设置标题：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image113.gif) |





 

### 坐标轴标签



同样的，用set_xlabel和set_ylabel可以设置X和Y轴的标签：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image114.gif) |





 

### 图例

图像中曲线的图例可以用两种方式添加，一种是用坐标轴对象的legend指令，对于之前定义的曲线添加 列表或元组形式的文本：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image115.gif) |





 

上面这种方法其实是MATLAB的API，如果图像上的曲线被添加或者删除时可能会报错（导致错误的添 加图例）。

一种更好的方法是在绘图或添加其他元素的时候利用label="label text" 关键字参数，然后用无参数的

legend指令把图例添加到图像上：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image116.gif) |





 

这种方法的优点是，如果在图像上添加或者删除曲线，图例会随之自动更新。

legend函数有一个可供选择的关键字参数loc，用来确定图例添加的位置，loc参数的允许值是数值型代  码，详见http://matplotlib.org/users/legend_guide.html#legend-location. 下面列举了一些常见的loc 值：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image117.gif) |





 

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image118.gif) |





 

 

运用上面介绍的关于标题，坐标轴标签和图例的内容，我们可以作出如下图像：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image119.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image121.gif)

## 文本格式: LaTeX，字体大小，字体样式

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image070.gif)

上面的绘制图像的方法都非常实用，但是还不能满足发表论文所需的标准。第一也是最重要的，我们需 要采用LaTeX文本格式；第二，我们需要能够调整字体大小以适应出版社所需的要求。

Matplotlib与LaTeX非常兼容，我们只需采用美元符号来封装LaTeX的文本（图例，题目，标签等等）， 例如："$y=x^3$"。

但是这里我们可能在转换LaTeX代码和Python字符串的过程中出现一点问题。在LaTeX中，我们经常用  反斜杠符号，例如用\alpha来产生符号α.   但是反斜杠在Python中已经有别的含义（转义码字符）。为了避免Python和LaTeX代码混淆，我们采用“原始”字符串。原始字符串带有前缀“r”，例如r"\alpha" 或者r'\alpha' 而不是 "\alpha" or '\alpha'：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image123.gif) |





 



我们也可以改变全局的字体大小和字体样式，使得图像中的所有文本元素都适用（刻度标记、坐标轴标 签，标题和图例等等）：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image125.gif) |





 

 

全局字体选择STIX字体样式是一个好的选择：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image126.gif) |





 



![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image128.gif)

或者，我们可以要求matplotlib在图像中采用LaTeX文本元素：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image130.gif) |





 

 

 

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image131.gif) |





## 设置颜色，线条宽度和线条类型

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image070.gif)



### 颜色

用matplotlib，我们可以运用各种方法定义线条颜色和其他图像元素。首先，我们可以运用MATLAB的  语法，定义'b'代表蓝色，'g'代表绿色，等等。同样，matplotlib也支持用MATLAB的API设置线条类型，  例如：'b.-'代表蓝色虚点线：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image132.gif) |





 

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image133.gif) |





 

 

我们也可以定义用颜色的英文名称定义，或者RGB十六进制码，或者用color和alpha关键字参数来选择 性提供α值：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image134.gif) |





 

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image135.gif) |





 

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image137.gif) |





 

### 线条和标记样式

我们可以用linewidth或者lw关键字参数来调整线宽度，线条样式则可以在linestyle或者ls关键字参数中  选择：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image138.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image139.gif)ax.plot(x, x+2, color="blue", linewidth=0.50) ax.plot(x, x+3, color="blue", linewidth=1.00) ax.plot(x, x+4, color="blue", linewidth=2.00)

 

\# 线条样式选择

ax.plot(x, x+5, color="red", lw=2, linestyle='-') ax.plot(x, x+6, color="red", lw=2, ls='-.')

ax.plot(x, x+7, color="red", lw=2, ls=':')

 

\# 自定义设置

line, = ax.plot(x, x+8, color="black", lw=1.50) line.set_dashes([5, 10, 15, 10]) # 格式：线长, 间距, ...

 

\# 标记符号

ax.plot(x, x+ 9, color="green", lw=2, ls='--', marker='+')

ax.plot(x, x+10, color="green", lw=2, ls='--', marker='o')

ax.plot(x, x+11, color="green", lw=2, ls='--', marker='s')

ax.plot(x, x+12, color="green", lw=2, ls='--', marker='1')

 

\# 标记大小和颜色

ax.plot(x, x+13, color="purple", lw=1, ls='-', marker='o', markersize=2) ax.plot(x, x+14, color="purple", lw=1, ls='-', marker='o', markersize=4) ax.plot(x, x+15, color="purple", lw=1, ls='-', marker='o', markersize=8, markerfacecolor="red")

ax.plot(x, x+16, color="purple", lw=1, ls='-', marker='s', markersize=8, markerfacecolor="yellow", markeredgewidth=2, markeredgecolor="blue");

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image141.gif) |





## 控制坐标轴外观

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image070.gif)

坐标轴外观是一个图像重要的方面，特别是我们经常需要更改它以满足出版刊物对于图像的要求。我们 需要控制刻度和标签的位置，更改字体大小和坐标轴标签。这一节中，我们将会学习如何控制matplotlib图像的这些参数。

### 绘图范围

首先我们想要设置坐标轴的范围，可以运用坐标轴对象中的set_ylim和set_xlim，或者axis('tight')来自  动设置“紧密结合”的坐标范围：



![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image142.gif)

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image144.gif) |





 

### 对数标度

对于单个或者两个坐标轴都可以设置对数标度。这个功能其实仅仅是Matplotlib全部变换系统的一个应  用。每个坐标标度可以分别用set_xscale和set_yscale来设置（值填入“log”即可）:

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image146.gif) |





 



## 刻度的放置以及用户定义的刻度标签

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image070.gif)

我们可以用set_xticks和set_yticks来明确确定坐标轴的刻度位置，二者都需要提供一个列表型数值。对 于每个刻度位置，我们可以用set_xticklabels和set_yticklabels来提供一个用户定义的文本标签：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image148.gif) |





 

Matplotlib图像还有很多更为高级的方法来控制主刻度和副刻度的位置，比如在不同环境下自动确定其  位置，详见http://matplotlib.org/api/ticker_api.html.

 

 

### ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image149.gif)科学计数法

对于坐标轴上出现的较大的数字，通常运用科学计数法：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image150.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image152.gif)

## 坐标数字以及坐标标签的位置

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image070.gif)

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image154.gif) |





 



![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image155.gif)

 

### 坐标轴位置调整

不幸的是，当保存图像时候，标签有时会被缩短，因此需要微调坐标轴的位置，这可以由

subplots_adjust来实现：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image157.gif) |





 

## 坐标轴网格

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image070.gif)

用坐标轴对象中的grid可以使用和取消网格线。我们也可以用plot函数中同样的关键字参数来定制网格 样式：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image158.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image160.gif)

## 轴刻度标记线

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image070.gif)

我们也可以改变轴刻度标记线的参数：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image162.gif) |





 

## 双刻度

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image070.gif)

 

有时在图像中采用两个x或y轴是十分有用的，例如单位不同的多条曲线画在一个图中。Matplotlib提供  了twinx和twiny函数：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image163.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image165.gif)

## x和y值为0的坐标轴

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image070.gif)

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image167.gif) |





 

**其他二维绘图样式**

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image070.gif)

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image168.gif)[除了常规的plot方法，还有一些其他的函数能够实现不同样式的绘图，所有可以绘制的图像种类请见htt p://matplotlib.org/gallery.html.](http://matplotlib.org/gallery.html)

下面展示一些有用的样式：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image169.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image170.gif)

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image171.gif) |





 

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image173.gif) |





 

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image175.gif) |





 



![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image176.gif)

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image178.gif) |





## 文字注释

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image070.gif)

采用text函数可以完成matplotlib图像的文字注释功能。和文字以及标题一样，它也支持LaTeX格式：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image180.gif) |





 

## 多个子图像的绘制和插入

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image070.gif)

采用fig.add_axes可以手动将坐标轴加入matplotlib图像中，或者用子图绘制的布局管理器，如

subplots，subplot2grid或者gridspec：



### subplots

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image182.gif) |





 

 

**subplot2grid**

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image184.gif) |





 

 

**gridspec**

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image185.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image186.gif)

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image188.gif) |





 

**add_axes**

用add_axes手动添加坐标轴对于添加元素于图像中非常有用：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image189.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image191.gif)

## 色图和等高线图

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image070.gif)

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image192.gif)色图和等高线图对于两个变量的绘图函数非常有用。在大多数函数中，我们采用色图编码一个维度的数 [据。下面列出了一些之前定义好的色图，他们对于确定定制版的色图是一种直接的方法，详见：http://](http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps)

[www.scipy.org/Cookbook/Matplotlib/Show_colormaps.](http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps)

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image193.gif) |





 

 

### pcolor函数

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image194.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image196.gif)

 

**imshow****函数**

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image198.gif) |





 

 

**contour****函数**

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image199.gif) |





 



![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image201.gif)

**3D** **图像**

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image070.gif)

 

在使用matplotlib中的3D图像之前，我们首先需要创建Axes3D类。3D坐标轴和2D坐标轴创建的方法一  样；或者更方便的方法是，在add_axes或者add_subplot中采用projection='3d'关键字参数。

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image202.gif) |





 

### 曲面图

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image204.gif) |





 

 

**三维线框图**



![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image205.gif)

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image207.gif) |





 

**带投影的等高线图**

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image208.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image210.gif)

 

**改变视角**

采用view_init可以改变3D图像的视角，该命令有两个参数，elevation和azimuth角度（度数）：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image212.gif) |





 

## 动图

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image070.gif)



Matplotlib也包含了一个简单的API用来产生一系列图像的动图。采用FuncAnimation函数，我们可以产  生由一系列图像组成的视频文件。该函数采用了如下命令：fig图像窗口，func更新图像所用的函数，

init_func组织图像的函数，frame产生的帧数，和blit指导动图函数只在帧数变动的时候更新（对于光滑  动图而言）：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image213.gif) |





 

为了使用matplotlib中的动图函数，我们首先调用matplotlib.animation：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image214.gif) |





 

 

生成的动画显示了钟摆的位置作为时间的函数：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image215.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image216.gif)

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image217.gif) |





 

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image218.gif) |





 



![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image219.gif)

 

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image221.gif) |





Note: 为了产生视频文件，我们需要安装ffmpeg或者avconv. 在Ubuntu上安装的指令:

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image222.gif) |





 

或者（更新的版本）

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image223.gif) |





 

在MacOSX中, 尝试:

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image224.gif) |





 

有兴趣的用户可以自行安装，这里不再演示视频文件。

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image225.gif) |







![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image226.gif)

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image227.gif) |





## 后端

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image070.gif)

Matplotlib有许多“后端”对产生的图像负责，不同的后端能够更产生不同样式的图和视频。非交互式的  后端（如 'agg'，'svg'，'pdf'等）是用来产生图像文件（如savefig函数），与此不同，交互式的后端

（如Qt4Agg，GTK，MaxOSX）能够运行GUI窗口，供用户进行交互式的使用图像。

可供选择的后端有:

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image228.gif) |





 

 

默认后端是agg，它基于栅格图形库，非常适合生成像PNG这样的光栅格式。

通常来说，我们并不需要改变默认后端，但是有时转换到例如PDF或者GTKcariro（如果是Linux系统） 时会非常有用，能够更产生高质量矢量图形而不是栅格图。

### 使用svg后端产生SVG

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image229.gif) |





 



![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image231.gif)![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image233.gif)![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image235.gif)![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image236.gif)

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image238.gif) |





 

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image239.gif) |





 

 

 

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image244.gif) |





 

​                            ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image246.gif)                                         



### IPython notebook 内联后端

 

当我们使用IPython notebook时，可以很方便的用matplotlib后端输出嵌入在notebook的图形文件。要激活这个后端，需要在开始的某处添加：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image247.gif) |





 

采用如下格式也能够激活内联后端：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image248.gif) |





 

不同之处在于%pylab inline调用了一系列函数包到全局地址空间（scipy，numpy），然而%matplotlib inline只在内联绘图时才调用。在IPython 1.0+的新的notebook中，建议使用%matplotlib inline，因为它更整洁，对于函数包的调用控制更多。通常，scipy和numpy分别通过如下形式调用：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image249.gif) |





 

内联后端有一系列的设置选择，可以通过IPython的命令%config来更新InlandBackend中的设置。例  如，我们可以转换SVG图像或者更高分别率的图像通过：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image250.gif) |





 

或者

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image251.gif) |





 

如需了解更多内容，请输入：

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image252.gif) |





 

 



![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image255.gif)

 

​                            ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image246.gif)                                         

 

### ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image256.gif)![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image258.gif)![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image259.gif)交互式后端（这使得Python脚本文件更有意义）

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image260.gif) |





 

 

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image261.gif) |





 

注意，当我们采用交互式后端是，需要调用plt.show()命令将图像显示在屏幕上。

# 推荐阅读

![img](file:///C:/Users/萝卜ovo/AppData/Local/Temp/msohtmlclip1/01/clip_image070.gif)



[http://www.matplotlib.org ](http://www.matplotlib.org/)- 官方网页

[https://github.com/matplotlib/matplotlib ](https://github.com/matplotlib/matplotlib)- matplotlib源代码

[http://matplotlib.org/gallery.html ](http://matplotlib.org/gallery.html)- 展示各种各样matplotlib函数包能够绘制的图像，强烈推荐！

[http://www.loria.fr/~rougier/teaching/matplotlib ](http://www.loria.fr/~rougier/teaching/matplotlib)- matplotlib课程

[http://scipy-lectures.github.io/matplotlib/matplotlib.html ](http://scipy-lectures.github.io/matplotlib/matplotlib.html)- 其他参考文献

